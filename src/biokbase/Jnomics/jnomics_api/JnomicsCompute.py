#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def alignBowtie(self, inPath, organism, outPath, opts, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - opts
     - auth
    """
    pass

  def alignBWA(self, inPath, organism, outPath, alignOpts, sampeOpts, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - alignOpts
     - sampeOpts
     - auth
    """
    pass

  def fastqtoPe(self, file1, file2, outpath, workingdir, auth):
    """
    Parameters:
     - file1
     - file2
     - outpath
     - workingdir
     - auth
    """
    pass

  def alignTophat(self, ref_genome, inPath, gtffile, outPath, alignOpts, workingdir, auth):
    """
    Parameters:
     - ref_genome
     - inPath
     - gtffile
     - outPath
     - alignOpts
     - workingdir
     - auth
    """
    pass

  def callCufflinks(self, inPath, outpath, ref_gtf, alignOpts, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - ref_gtf
     - alignOpts
     - workingdir
     - auth
    """
    pass

  def callCuffmerge(self, inPath, ref_genome, outpath, alignOpts, gtffile, workingdir, auth):
    """
    Parameters:
     - inPath
     - ref_genome
     - outpath
     - alignOpts
     - gtffile
     - workingdir
     - auth
    """
    pass

  def callCuffdiff(self, inPath, outpath, ref_genome, alignOpts, condn_labels, merged_gtf, withReplicates, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - ref_genome
     - alignOpts
     - condn_labels
     - merged_gtf
     - withReplicates
     - workingdir
     - auth
    """
    pass

  def callCuffcompare(self, inPath, outpath, alignOpts, gtffile, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - alignOpts
     - gtffile
     - workingdir
     - auth
    """
    pass

  def ShockRead(self, nodeId, inPath, auth):
    """
    Parameters:
     - nodeId
     - inPath
     - auth
    """
    pass

  def ShockWrite(self, filename, hdfsPath, auth):
    """
    Parameters:
     - filename
     - hdfsPath
     - auth
    """
    pass

  def workspaceUpload(self, filename, genome_id, desc, title, srcDate, onto_term_id, onto_term_def, onto_term_name, seq_type, shock_id, src_id, working_dir, auth):
    """
    Parameters:
     - filename
     - genome_id
     - desc
     - title
     - srcDate
     - onto_term_id
     - onto_term_def
     - onto_term_name
     - seq_type
     - shock_id
     - src_id
     - working_dir
     - auth
    """
    pass

  def ShockBatchWrite(self, inPath, outPath, auth):
    """
    Parameters:
     - inPath
     - outPath
     - auth
    """
    pass

  def snpSamtools(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    pass

  def getJobStatus(self, jobID, auth):
    """
    Parameters:
     - jobID
     - auth
    """
    pass

  def getGridJobStatus(self, jobID, auth):
    """
    Parameters:
     - jobID
     - auth
    """
    pass

  def getAllJobs(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def mergeVCF(self, inDir, inAlignments, outVCF, auth):
    """
    Parameters:
     - inDir
     - inAlignments
     - outVCF
     - auth
    """
    pass

  def mergeCovariate(self, inDir, outCov, auth):
    """
    Parameters:
     - inDir
     - outCov
     - auth
    """
    pass

  def gatkRealign(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    pass

  def gatkCallVariants(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    pass

  def gatkCountCovariates(self, inPath, organism, vcfMask, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - vcfMask
     - outPath
     - auth
    """
    pass

  def gatkRecalibrate(self, inPath, organism, recalFile, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - recalFile
     - outPath
     - auth
    """
    pass

  def runSNPPipeline(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    pass

  def pairReads(self, file1, file2, outFile, auth):
    """
    Parameters:
     - file1
     - file2
     - outFile
     - auth
    """
    pass

  def singleReads(self, file, outFile, auth):
    """
    Parameters:
     - file
     - outFile
     - auth
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def alignBowtie(self, inPath, organism, outPath, opts, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - opts
     - auth
    """
    self.send_alignBowtie(inPath, organism, outPath, opts, auth)
    return self.recv_alignBowtie()

  def send_alignBowtie(self, inPath, organism, outPath, opts, auth):
    self._oprot.writeMessageBegin('alignBowtie', TMessageType.CALL, self._seqid)
    args = alignBowtie_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.opts = opts
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alignBowtie(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alignBowtie_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alignBowtie failed: unknown result");

  def alignBWA(self, inPath, organism, outPath, alignOpts, sampeOpts, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - alignOpts
     - sampeOpts
     - auth
    """
    self.send_alignBWA(inPath, organism, outPath, alignOpts, sampeOpts, auth)
    return self.recv_alignBWA()

  def send_alignBWA(self, inPath, organism, outPath, alignOpts, sampeOpts, auth):
    self._oprot.writeMessageBegin('alignBWA', TMessageType.CALL, self._seqid)
    args = alignBWA_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.alignOpts = alignOpts
    args.sampeOpts = sampeOpts
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alignBWA(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alignBWA_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alignBWA failed: unknown result");

  def fastqtoPe(self, file1, file2, outpath, workingdir, auth):
    """
    Parameters:
     - file1
     - file2
     - outpath
     - workingdir
     - auth
    """
    self.send_fastqtoPe(file1, file2, outpath, workingdir, auth)
    return self.recv_fastqtoPe()

  def send_fastqtoPe(self, file1, file2, outpath, workingdir, auth):
    self._oprot.writeMessageBegin('fastqtoPe', TMessageType.CALL, self._seqid)
    args = fastqtoPe_args()
    args.file1 = file1
    args.file2 = file2
    args.outpath = outpath
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fastqtoPe(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fastqtoPe_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fastqtoPe failed: unknown result");

  def alignTophat(self, ref_genome, inPath, gtffile, outPath, alignOpts, workingdir, auth):
    """
    Parameters:
     - ref_genome
     - inPath
     - gtffile
     - outPath
     - alignOpts
     - workingdir
     - auth
    """
    self.send_alignTophat(ref_genome, inPath, gtffile, outPath, alignOpts, workingdir, auth)
    return self.recv_alignTophat()

  def send_alignTophat(self, ref_genome, inPath, gtffile, outPath, alignOpts, workingdir, auth):
    self._oprot.writeMessageBegin('alignTophat', TMessageType.CALL, self._seqid)
    args = alignTophat_args()
    args.ref_genome = ref_genome
    args.inPath = inPath
    args.gtffile = gtffile
    args.outPath = outPath
    args.alignOpts = alignOpts
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alignTophat(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alignTophat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alignTophat failed: unknown result");

  def callCufflinks(self, inPath, outpath, ref_gtf, alignOpts, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - ref_gtf
     - alignOpts
     - workingdir
     - auth
    """
    self.send_callCufflinks(inPath, outpath, ref_gtf, alignOpts, workingdir, auth)
    return self.recv_callCufflinks()

  def send_callCufflinks(self, inPath, outpath, ref_gtf, alignOpts, workingdir, auth):
    self._oprot.writeMessageBegin('callCufflinks', TMessageType.CALL, self._seqid)
    args = callCufflinks_args()
    args.inPath = inPath
    args.outpath = outpath
    args.ref_gtf = ref_gtf
    args.alignOpts = alignOpts
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_callCufflinks(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = callCufflinks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "callCufflinks failed: unknown result");

  def callCuffmerge(self, inPath, ref_genome, outpath, alignOpts, gtffile, workingdir, auth):
    """
    Parameters:
     - inPath
     - ref_genome
     - outpath
     - alignOpts
     - gtffile
     - workingdir
     - auth
    """
    self.send_callCuffmerge(inPath, ref_genome, outpath, alignOpts, gtffile, workingdir, auth)
    return self.recv_callCuffmerge()

  def send_callCuffmerge(self, inPath, ref_genome, outpath, alignOpts, gtffile, workingdir, auth):
    self._oprot.writeMessageBegin('callCuffmerge', TMessageType.CALL, self._seqid)
    args = callCuffmerge_args()
    args.inPath = inPath
    args.ref_genome = ref_genome
    args.outpath = outpath
    args.alignOpts = alignOpts
    args.gtffile = gtffile
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_callCuffmerge(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = callCuffmerge_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "callCuffmerge failed: unknown result");

  def callCuffdiff(self, inPath, outpath, ref_genome, alignOpts, condn_labels, merged_gtf, withReplicates, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - ref_genome
     - alignOpts
     - condn_labels
     - merged_gtf
     - withReplicates
     - workingdir
     - auth
    """
    self.send_callCuffdiff(inPath, outpath, ref_genome, alignOpts, condn_labels, merged_gtf, withReplicates, workingdir, auth)
    return self.recv_callCuffdiff()

  def send_callCuffdiff(self, inPath, outpath, ref_genome, alignOpts, condn_labels, merged_gtf, withReplicates, workingdir, auth):
    self._oprot.writeMessageBegin('callCuffdiff', TMessageType.CALL, self._seqid)
    args = callCuffdiff_args()
    args.inPath = inPath
    args.outpath = outpath
    args.ref_genome = ref_genome
    args.alignOpts = alignOpts
    args.condn_labels = condn_labels
    args.merged_gtf = merged_gtf
    args.withReplicates = withReplicates
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_callCuffdiff(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = callCuffdiff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "callCuffdiff failed: unknown result");

  def callCuffcompare(self, inPath, outpath, alignOpts, gtffile, workingdir, auth):
    """
    Parameters:
     - inPath
     - outpath
     - alignOpts
     - gtffile
     - workingdir
     - auth
    """
    self.send_callCuffcompare(inPath, outpath, alignOpts, gtffile, workingdir, auth)
    return self.recv_callCuffcompare()

  def send_callCuffcompare(self, inPath, outpath, alignOpts, gtffile, workingdir, auth):
    self._oprot.writeMessageBegin('callCuffcompare', TMessageType.CALL, self._seqid)
    args = callCuffcompare_args()
    args.inPath = inPath
    args.outpath = outpath
    args.alignOpts = alignOpts
    args.gtffile = gtffile
    args.workingdir = workingdir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_callCuffcompare(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = callCuffcompare_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "callCuffcompare failed: unknown result");

  def ShockRead(self, nodeId, inPath, auth):
    """
    Parameters:
     - nodeId
     - inPath
     - auth
    """
    self.send_ShockRead(nodeId, inPath, auth)
    return self.recv_ShockRead()

  def send_ShockRead(self, nodeId, inPath, auth):
    self._oprot.writeMessageBegin('ShockRead', TMessageType.CALL, self._seqid)
    args = ShockRead_args()
    args.nodeId = nodeId
    args.inPath = inPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ShockRead(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ShockRead_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ShockRead failed: unknown result");

  def ShockWrite(self, filename, hdfsPath, auth):
    """
    Parameters:
     - filename
     - hdfsPath
     - auth
    """
    self.send_ShockWrite(filename, hdfsPath, auth)
    return self.recv_ShockWrite()

  def send_ShockWrite(self, filename, hdfsPath, auth):
    self._oprot.writeMessageBegin('ShockWrite', TMessageType.CALL, self._seqid)
    args = ShockWrite_args()
    args.filename = filename
    args.hdfsPath = hdfsPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ShockWrite(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ShockWrite_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ShockWrite failed: unknown result");

  def workspaceUpload(self, filename, genome_id, desc, title, srcDate, onto_term_id, onto_term_def, onto_term_name, seq_type, shock_id, src_id, working_dir, auth):
    """
    Parameters:
     - filename
     - genome_id
     - desc
     - title
     - srcDate
     - onto_term_id
     - onto_term_def
     - onto_term_name
     - seq_type
     - shock_id
     - src_id
     - working_dir
     - auth
    """
    self.send_workspaceUpload(filename, genome_id, desc, title, srcDate, onto_term_id, onto_term_def, onto_term_name, seq_type, shock_id, src_id, working_dir, auth)
    return self.recv_workspaceUpload()

  def send_workspaceUpload(self, filename, genome_id, desc, title, srcDate, onto_term_id, onto_term_def, onto_term_name, seq_type, shock_id, src_id, working_dir, auth):
    self._oprot.writeMessageBegin('workspaceUpload', TMessageType.CALL, self._seqid)
    args = workspaceUpload_args()
    args.filename = filename
    args.genome_id = genome_id
    args.desc = desc
    args.title = title
    args.srcDate = srcDate
    args.onto_term_id = onto_term_id
    args.onto_term_def = onto_term_def
    args.onto_term_name = onto_term_name
    args.seq_type = seq_type
    args.shock_id = shock_id
    args.src_id = src_id
    args.working_dir = working_dir
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_workspaceUpload(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = workspaceUpload_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "workspaceUpload failed: unknown result");

  def ShockBatchWrite(self, inPath, outPath, auth):
    """
    Parameters:
     - inPath
     - outPath
     - auth
    """
    self.send_ShockBatchWrite(inPath, outPath, auth)
    return self.recv_ShockBatchWrite()

  def send_ShockBatchWrite(self, inPath, outPath, auth):
    self._oprot.writeMessageBegin('ShockBatchWrite', TMessageType.CALL, self._seqid)
    args = ShockBatchWrite_args()
    args.inPath = inPath
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ShockBatchWrite(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ShockBatchWrite_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ShockBatchWrite failed: unknown result");

  def snpSamtools(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    self.send_snpSamtools(inPath, organism, outPath, auth)
    return self.recv_snpSamtools()

  def send_snpSamtools(self, inPath, organism, outPath, auth):
    self._oprot.writeMessageBegin('snpSamtools', TMessageType.CALL, self._seqid)
    args = snpSamtools_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snpSamtools(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = snpSamtools_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snpSamtools failed: unknown result");

  def getJobStatus(self, jobID, auth):
    """
    Parameters:
     - jobID
     - auth
    """
    self.send_getJobStatus(jobID, auth)
    return self.recv_getJobStatus()

  def send_getJobStatus(self, jobID, auth):
    self._oprot.writeMessageBegin('getJobStatus', TMessageType.CALL, self._seqid)
    args = getJobStatus_args()
    args.jobID = jobID
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getJobStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getJobStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getJobStatus failed: unknown result");

  def getGridJobStatus(self, jobID, auth):
    """
    Parameters:
     - jobID
     - auth
    """
    self.send_getGridJobStatus(jobID, auth)
    return self.recv_getGridJobStatus()

  def send_getGridJobStatus(self, jobID, auth):
    self._oprot.writeMessageBegin('getGridJobStatus', TMessageType.CALL, self._seqid)
    args = getGridJobStatus_args()
    args.jobID = jobID
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGridJobStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGridJobStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGridJobStatus failed: unknown result");

  def getAllJobs(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getAllJobs(auth)
    return self.recv_getAllJobs()

  def send_getAllJobs(self, auth):
    self._oprot.writeMessageBegin('getAllJobs', TMessageType.CALL, self._seqid)
    args = getAllJobs_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllJobs(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllJobs_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllJobs failed: unknown result");

  def mergeVCF(self, inDir, inAlignments, outVCF, auth):
    """
    Parameters:
     - inDir
     - inAlignments
     - outVCF
     - auth
    """
    self.send_mergeVCF(inDir, inAlignments, outVCF, auth)
    return self.recv_mergeVCF()

  def send_mergeVCF(self, inDir, inAlignments, outVCF, auth):
    self._oprot.writeMessageBegin('mergeVCF', TMessageType.CALL, self._seqid)
    args = mergeVCF_args()
    args.inDir = inDir
    args.inAlignments = inAlignments
    args.outVCF = outVCF
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mergeVCF(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mergeVCF_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mergeVCF failed: unknown result");

  def mergeCovariate(self, inDir, outCov, auth):
    """
    Parameters:
     - inDir
     - outCov
     - auth
    """
    self.send_mergeCovariate(inDir, outCov, auth)
    return self.recv_mergeCovariate()

  def send_mergeCovariate(self, inDir, outCov, auth):
    self._oprot.writeMessageBegin('mergeCovariate', TMessageType.CALL, self._seqid)
    args = mergeCovariate_args()
    args.inDir = inDir
    args.outCov = outCov
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mergeCovariate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mergeCovariate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mergeCovariate failed: unknown result");

  def gatkRealign(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    self.send_gatkRealign(inPath, organism, outPath, auth)
    return self.recv_gatkRealign()

  def send_gatkRealign(self, inPath, organism, outPath, auth):
    self._oprot.writeMessageBegin('gatkRealign', TMessageType.CALL, self._seqid)
    args = gatkRealign_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_gatkRealign(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = gatkRealign_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "gatkRealign failed: unknown result");

  def gatkCallVariants(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    self.send_gatkCallVariants(inPath, organism, outPath, auth)
    return self.recv_gatkCallVariants()

  def send_gatkCallVariants(self, inPath, organism, outPath, auth):
    self._oprot.writeMessageBegin('gatkCallVariants', TMessageType.CALL, self._seqid)
    args = gatkCallVariants_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_gatkCallVariants(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = gatkCallVariants_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "gatkCallVariants failed: unknown result");

  def gatkCountCovariates(self, inPath, organism, vcfMask, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - vcfMask
     - outPath
     - auth
    """
    self.send_gatkCountCovariates(inPath, organism, vcfMask, outPath, auth)
    return self.recv_gatkCountCovariates()

  def send_gatkCountCovariates(self, inPath, organism, vcfMask, outPath, auth):
    self._oprot.writeMessageBegin('gatkCountCovariates', TMessageType.CALL, self._seqid)
    args = gatkCountCovariates_args()
    args.inPath = inPath
    args.organism = organism
    args.vcfMask = vcfMask
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_gatkCountCovariates(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = gatkCountCovariates_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "gatkCountCovariates failed: unknown result");

  def gatkRecalibrate(self, inPath, organism, recalFile, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - recalFile
     - outPath
     - auth
    """
    self.send_gatkRecalibrate(inPath, organism, recalFile, outPath, auth)
    return self.recv_gatkRecalibrate()

  def send_gatkRecalibrate(self, inPath, organism, recalFile, outPath, auth):
    self._oprot.writeMessageBegin('gatkRecalibrate', TMessageType.CALL, self._seqid)
    args = gatkRecalibrate_args()
    args.inPath = inPath
    args.organism = organism
    args.recalFile = recalFile
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_gatkRecalibrate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = gatkRecalibrate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "gatkRecalibrate failed: unknown result");

  def runSNPPipeline(self, inPath, organism, outPath, auth):
    """
    Parameters:
     - inPath
     - organism
     - outPath
     - auth
    """
    self.send_runSNPPipeline(inPath, organism, outPath, auth)
    return self.recv_runSNPPipeline()

  def send_runSNPPipeline(self, inPath, organism, outPath, auth):
    self._oprot.writeMessageBegin('runSNPPipeline', TMessageType.CALL, self._seqid)
    args = runSNPPipeline_args()
    args.inPath = inPath
    args.organism = organism
    args.outPath = outPath
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_runSNPPipeline(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = runSNPPipeline_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "runSNPPipeline failed: unknown result");

  def pairReads(self, file1, file2, outFile, auth):
    """
    Parameters:
     - file1
     - file2
     - outFile
     - auth
    """
    self.send_pairReads(file1, file2, outFile, auth)
    return self.recv_pairReads()

  def send_pairReads(self, file1, file2, outFile, auth):
    self._oprot.writeMessageBegin('pairReads', TMessageType.CALL, self._seqid)
    args = pairReads_args()
    args.file1 = file1
    args.file2 = file2
    args.outFile = outFile
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pairReads(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = pairReads_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pairReads failed: unknown result");

  def singleReads(self, file, outFile, auth):
    """
    Parameters:
     - file
     - outFile
     - auth
    """
    self.send_singleReads(file, outFile, auth)
    return self.recv_singleReads()

  def send_singleReads(self, file, outFile, auth):
    self._oprot.writeMessageBegin('singleReads', TMessageType.CALL, self._seqid)
    args = singleReads_args()
    args.file = file
    args.outFile = outFile
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_singleReads(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = singleReads_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.je is not None:
      raise result.je
    raise TApplicationException(TApplicationException.MISSING_RESULT, "singleReads failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["alignBowtie"] = Processor.process_alignBowtie
    self._processMap["alignBWA"] = Processor.process_alignBWA
    self._processMap["fastqtoPe"] = Processor.process_fastqtoPe
    self._processMap["alignTophat"] = Processor.process_alignTophat
    self._processMap["callCufflinks"] = Processor.process_callCufflinks
    self._processMap["callCuffmerge"] = Processor.process_callCuffmerge
    self._processMap["callCuffdiff"] = Processor.process_callCuffdiff
    self._processMap["callCuffcompare"] = Processor.process_callCuffcompare
    self._processMap["ShockRead"] = Processor.process_ShockRead
    self._processMap["ShockWrite"] = Processor.process_ShockWrite
    self._processMap["workspaceUpload"] = Processor.process_workspaceUpload
    self._processMap["ShockBatchWrite"] = Processor.process_ShockBatchWrite
    self._processMap["snpSamtools"] = Processor.process_snpSamtools
    self._processMap["getJobStatus"] = Processor.process_getJobStatus
    self._processMap["getGridJobStatus"] = Processor.process_getGridJobStatus
    self._processMap["getAllJobs"] = Processor.process_getAllJobs
    self._processMap["mergeVCF"] = Processor.process_mergeVCF
    self._processMap["mergeCovariate"] = Processor.process_mergeCovariate
    self._processMap["gatkRealign"] = Processor.process_gatkRealign
    self._processMap["gatkCallVariants"] = Processor.process_gatkCallVariants
    self._processMap["gatkCountCovariates"] = Processor.process_gatkCountCovariates
    self._processMap["gatkRecalibrate"] = Processor.process_gatkRecalibrate
    self._processMap["runSNPPipeline"] = Processor.process_runSNPPipeline
    self._processMap["pairReads"] = Processor.process_pairReads
    self._processMap["singleReads"] = Processor.process_singleReads

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_alignBowtie(self, seqid, iprot, oprot):
    args = alignBowtie_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alignBowtie_result()
    try:
      result.success = self._handler.alignBowtie(args.inPath, args.organism, args.outPath, args.opts, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("alignBowtie", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alignBWA(self, seqid, iprot, oprot):
    args = alignBWA_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alignBWA_result()
    try:
      result.success = self._handler.alignBWA(args.inPath, args.organism, args.outPath, args.alignOpts, args.sampeOpts, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("alignBWA", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fastqtoPe(self, seqid, iprot, oprot):
    args = fastqtoPe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fastqtoPe_result()
    try:
      result.success = self._handler.fastqtoPe(args.file1, args.file2, args.outpath, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("fastqtoPe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alignTophat(self, seqid, iprot, oprot):
    args = alignTophat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alignTophat_result()
    try:
      result.success = self._handler.alignTophat(args.ref_genome, args.inPath, args.gtffile, args.outPath, args.alignOpts, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("alignTophat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_callCufflinks(self, seqid, iprot, oprot):
    args = callCufflinks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = callCufflinks_result()
    try:
      result.success = self._handler.callCufflinks(args.inPath, args.outpath, args.ref_gtf, args.alignOpts, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("callCufflinks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_callCuffmerge(self, seqid, iprot, oprot):
    args = callCuffmerge_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = callCuffmerge_result()
    try:
      result.success = self._handler.callCuffmerge(args.inPath, args.ref_genome, args.outpath, args.alignOpts, args.gtffile, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("callCuffmerge", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_callCuffdiff(self, seqid, iprot, oprot):
    args = callCuffdiff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = callCuffdiff_result()
    try:
      result.success = self._handler.callCuffdiff(args.inPath, args.outpath, args.ref_genome, args.alignOpts, args.condn_labels, args.merged_gtf, args.withReplicates, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("callCuffdiff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_callCuffcompare(self, seqid, iprot, oprot):
    args = callCuffcompare_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = callCuffcompare_result()
    try:
      result.success = self._handler.callCuffcompare(args.inPath, args.outpath, args.alignOpts, args.gtffile, args.workingdir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("callCuffcompare", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ShockRead(self, seqid, iprot, oprot):
    args = ShockRead_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ShockRead_result()
    try:
      result.success = self._handler.ShockRead(args.nodeId, args.inPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("ShockRead", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ShockWrite(self, seqid, iprot, oprot):
    args = ShockWrite_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ShockWrite_result()
    try:
      result.success = self._handler.ShockWrite(args.filename, args.hdfsPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("ShockWrite", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_workspaceUpload(self, seqid, iprot, oprot):
    args = workspaceUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = workspaceUpload_result()
    try:
      result.success = self._handler.workspaceUpload(args.filename, args.genome_id, args.desc, args.title, args.srcDate, args.onto_term_id, args.onto_term_def, args.onto_term_name, args.seq_type, args.shock_id, args.src_id, args.working_dir, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("workspaceUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ShockBatchWrite(self, seqid, iprot, oprot):
    args = ShockBatchWrite_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ShockBatchWrite_result()
    try:
      result.success = self._handler.ShockBatchWrite(args.inPath, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("ShockBatchWrite", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snpSamtools(self, seqid, iprot, oprot):
    args = snpSamtools_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snpSamtools_result()
    try:
      result.success = self._handler.snpSamtools(args.inPath, args.organism, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("snpSamtools", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getJobStatus(self, seqid, iprot, oprot):
    args = getJobStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getJobStatus_result()
    try:
      result.success = self._handler.getJobStatus(args.jobID, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("getJobStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGridJobStatus(self, seqid, iprot, oprot):
    args = getGridJobStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGridJobStatus_result()
    try:
      result.success = self._handler.getGridJobStatus(args.jobID, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("getGridJobStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllJobs(self, seqid, iprot, oprot):
    args = getAllJobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllJobs_result()
    try:
      result.success = self._handler.getAllJobs(args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("getAllJobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mergeVCF(self, seqid, iprot, oprot):
    args = mergeVCF_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mergeVCF_result()
    try:
      result.success = self._handler.mergeVCF(args.inDir, args.inAlignments, args.outVCF, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("mergeVCF", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mergeCovariate(self, seqid, iprot, oprot):
    args = mergeCovariate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mergeCovariate_result()
    try:
      result.success = self._handler.mergeCovariate(args.inDir, args.outCov, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("mergeCovariate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_gatkRealign(self, seqid, iprot, oprot):
    args = gatkRealign_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = gatkRealign_result()
    try:
      result.success = self._handler.gatkRealign(args.inPath, args.organism, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("gatkRealign", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_gatkCallVariants(self, seqid, iprot, oprot):
    args = gatkCallVariants_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = gatkCallVariants_result()
    try:
      result.success = self._handler.gatkCallVariants(args.inPath, args.organism, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("gatkCallVariants", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_gatkCountCovariates(self, seqid, iprot, oprot):
    args = gatkCountCovariates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = gatkCountCovariates_result()
    try:
      result.success = self._handler.gatkCountCovariates(args.inPath, args.organism, args.vcfMask, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("gatkCountCovariates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_gatkRecalibrate(self, seqid, iprot, oprot):
    args = gatkRecalibrate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = gatkRecalibrate_result()
    try:
      result.success = self._handler.gatkRecalibrate(args.inPath, args.organism, args.recalFile, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("gatkRecalibrate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_runSNPPipeline(self, seqid, iprot, oprot):
    args = runSNPPipeline_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = runSNPPipeline_result()
    try:
      result.success = self._handler.runSNPPipeline(args.inPath, args.organism, args.outPath, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("runSNPPipeline", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pairReads(self, seqid, iprot, oprot):
    args = pairReads_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pairReads_result()
    try:
      result.success = self._handler.pairReads(args.file1, args.file2, args.outFile, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("pairReads", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_singleReads(self, seqid, iprot, oprot):
    args = singleReads_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = singleReads_result()
    try:
      result.success = self._handler.singleReads(args.file, args.outFile, args.auth)
    except JnomicsThriftException, je:
      result.je = je
    oprot.writeMessageBegin("singleReads", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class alignBowtie_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - opts
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRING, 'opts', None, None, ), # 4
    (5, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 5
  )

  def __init__(self, inPath=None, organism=None, outPath=None, opts=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.opts = opts
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.opts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignBowtie_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.opts is not None:
      oprot.writeFieldBegin('opts', TType.STRING, 4)
      oprot.writeString(self.opts)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 5)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignBowtie_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignBowtie_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignBWA_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - alignOpts
   - sampeOpts
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRING, 'alignOpts', None, None, ), # 4
    (5, TType.STRING, 'sampeOpts', None, None, ), # 5
    (6, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 6
  )

  def __init__(self, inPath=None, organism=None, outPath=None, alignOpts=None, sampeOpts=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.alignOpts = alignOpts
    self.sampeOpts = sampeOpts
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.sampeOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignBWA_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 4)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.sampeOpts is not None:
      oprot.writeFieldBegin('sampeOpts', TType.STRING, 5)
      oprot.writeString(self.sampeOpts)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 6)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignBWA_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignBWA_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fastqtoPe_args:
  """
  Attributes:
   - file1
   - file2
   - outpath
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file1', None, None, ), # 1
    (2, TType.STRING, 'file2', None, None, ), # 2
    (3, TType.STRING, 'outpath', None, None, ), # 3
    (4, TType.STRING, 'workingdir', None, None, ), # 4
    (5, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 5
  )

  def __init__(self, file1=None, file2=None, outpath=None, workingdir=None, auth=None,):
    self.file1 = file1
    self.file2 = file2
    self.outpath = outpath
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.file2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fastqtoPe_args')
    if self.file1 is not None:
      oprot.writeFieldBegin('file1', TType.STRING, 1)
      oprot.writeString(self.file1)
      oprot.writeFieldEnd()
    if self.file2 is not None:
      oprot.writeFieldBegin('file2', TType.STRING, 2)
      oprot.writeString(self.file2)
      oprot.writeFieldEnd()
    if self.outpath is not None:
      oprot.writeFieldBegin('outpath', TType.STRING, 3)
      oprot.writeString(self.outpath)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 4)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 5)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fastqtoPe_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fastqtoPe_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignTophat_args:
  """
  Attributes:
   - ref_genome
   - inPath
   - gtffile
   - outPath
   - alignOpts
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ref_genome', None, None, ), # 1
    (2, TType.STRING, 'inPath', None, None, ), # 2
    (3, TType.STRING, 'gtffile', None, None, ), # 3
    (4, TType.STRING, 'outPath', None, None, ), # 4
    (5, TType.STRING, 'alignOpts', None, None, ), # 5
    (6, TType.STRING, 'workingdir', None, None, ), # 6
    (7, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 7
  )

  def __init__(self, ref_genome=None, inPath=None, gtffile=None, outPath=None, alignOpts=None, workingdir=None, auth=None,):
    self.ref_genome = ref_genome
    self.inPath = inPath
    self.gtffile = gtffile
    self.outPath = outPath
    self.alignOpts = alignOpts
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ref_genome = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.gtffile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignTophat_args')
    if self.ref_genome is not None:
      oprot.writeFieldBegin('ref_genome', TType.STRING, 1)
      oprot.writeString(self.ref_genome)
      oprot.writeFieldEnd()
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 2)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.gtffile is not None:
      oprot.writeFieldBegin('gtffile', TType.STRING, 3)
      oprot.writeString(self.gtffile)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 4)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 5)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 6)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 7)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignTophat_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignTophat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCufflinks_args:
  """
  Attributes:
   - inPath
   - outpath
   - ref_gtf
   - alignOpts
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'outpath', None, None, ), # 2
    (3, TType.STRING, 'ref_gtf', None, None, ), # 3
    (4, TType.STRING, 'alignOpts', None, None, ), # 4
    (5, TType.STRING, 'workingdir', None, None, ), # 5
    (6, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 6
  )

  def __init__(self, inPath=None, outpath=None, ref_gtf=None, alignOpts=None, workingdir=None, auth=None,):
    self.inPath = inPath
    self.outpath = outpath
    self.ref_gtf = ref_gtf
    self.alignOpts = alignOpts
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref_gtf = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCufflinks_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.outpath is not None:
      oprot.writeFieldBegin('outpath', TType.STRING, 2)
      oprot.writeString(self.outpath)
      oprot.writeFieldEnd()
    if self.ref_gtf is not None:
      oprot.writeFieldBegin('ref_gtf', TType.STRING, 3)
      oprot.writeString(self.ref_gtf)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 4)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 5)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 6)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCufflinks_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCufflinks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffmerge_args:
  """
  Attributes:
   - inPath
   - ref_genome
   - outpath
   - alignOpts
   - gtffile
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'ref_genome', None, None, ), # 2
    (3, TType.STRING, 'outpath', None, None, ), # 3
    (4, TType.STRING, 'alignOpts', None, None, ), # 4
    (5, TType.STRING, 'gtffile', None, None, ), # 5
    (6, TType.STRING, 'workingdir', None, None, ), # 6
    (7, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 7
  )

  def __init__(self, inPath=None, ref_genome=None, outpath=None, alignOpts=None, gtffile=None, workingdir=None, auth=None,):
    self.inPath = inPath
    self.ref_genome = ref_genome
    self.outpath = outpath
    self.alignOpts = alignOpts
    self.gtffile = gtffile
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref_genome = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.gtffile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffmerge_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.ref_genome is not None:
      oprot.writeFieldBegin('ref_genome', TType.STRING, 2)
      oprot.writeString(self.ref_genome)
      oprot.writeFieldEnd()
    if self.outpath is not None:
      oprot.writeFieldBegin('outpath', TType.STRING, 3)
      oprot.writeString(self.outpath)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 4)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.gtffile is not None:
      oprot.writeFieldBegin('gtffile', TType.STRING, 5)
      oprot.writeString(self.gtffile)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 6)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 7)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffmerge_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffmerge_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffdiff_args:
  """
  Attributes:
   - inPath
   - outpath
   - ref_genome
   - alignOpts
   - condn_labels
   - merged_gtf
   - withReplicates
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'outpath', None, None, ), # 2
    (3, TType.STRING, 'ref_genome', None, None, ), # 3
    (4, TType.STRING, 'alignOpts', None, None, ), # 4
    (5, TType.STRING, 'condn_labels', None, None, ), # 5
    (6, TType.STRING, 'merged_gtf', None, None, ), # 6
    (7, TType.STRING, 'withReplicates', None, None, ), # 7
    (8, TType.STRING, 'workingdir', None, None, ), # 8
    (9, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 9
  )

  def __init__(self, inPath=None, outpath=None, ref_genome=None, alignOpts=None, condn_labels=None, merged_gtf=None, withReplicates=None, workingdir=None, auth=None,):
    self.inPath = inPath
    self.outpath = outpath
    self.ref_genome = ref_genome
    self.alignOpts = alignOpts
    self.condn_labels = condn_labels
    self.merged_gtf = merged_gtf
    self.withReplicates = withReplicates
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref_genome = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.condn_labels = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.merged_gtf = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.withReplicates = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffdiff_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.outpath is not None:
      oprot.writeFieldBegin('outpath', TType.STRING, 2)
      oprot.writeString(self.outpath)
      oprot.writeFieldEnd()
    if self.ref_genome is not None:
      oprot.writeFieldBegin('ref_genome', TType.STRING, 3)
      oprot.writeString(self.ref_genome)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 4)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.condn_labels is not None:
      oprot.writeFieldBegin('condn_labels', TType.STRING, 5)
      oprot.writeString(self.condn_labels)
      oprot.writeFieldEnd()
    if self.merged_gtf is not None:
      oprot.writeFieldBegin('merged_gtf', TType.STRING, 6)
      oprot.writeString(self.merged_gtf)
      oprot.writeFieldEnd()
    if self.withReplicates is not None:
      oprot.writeFieldBegin('withReplicates', TType.STRING, 7)
      oprot.writeString(self.withReplicates)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 8)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 9)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffdiff_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffdiff_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffcompare_args:
  """
  Attributes:
   - inPath
   - outpath
   - alignOpts
   - gtffile
   - workingdir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'outpath', None, None, ), # 2
    (3, TType.STRING, 'alignOpts', None, None, ), # 3
    (4, TType.STRING, 'gtffile', None, None, ), # 4
    (5, TType.STRING, 'workingdir', None, None, ), # 5
    (6, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 6
  )

  def __init__(self, inPath=None, outpath=None, alignOpts=None, gtffile=None, workingdir=None, auth=None,):
    self.inPath = inPath
    self.outpath = outpath
    self.alignOpts = alignOpts
    self.gtffile = gtffile
    self.workingdir = workingdir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.alignOpts = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.gtffile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.workingdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffcompare_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.outpath is not None:
      oprot.writeFieldBegin('outpath', TType.STRING, 2)
      oprot.writeString(self.outpath)
      oprot.writeFieldEnd()
    if self.alignOpts is not None:
      oprot.writeFieldBegin('alignOpts', TType.STRING, 3)
      oprot.writeString(self.alignOpts)
      oprot.writeFieldEnd()
    if self.gtffile is not None:
      oprot.writeFieldBegin('gtffile', TType.STRING, 4)
      oprot.writeString(self.gtffile)
      oprot.writeFieldEnd()
    if self.workingdir is not None:
      oprot.writeFieldBegin('workingdir', TType.STRING, 5)
      oprot.writeString(self.workingdir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 6)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class callCuffcompare_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('callCuffcompare_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockRead_args:
  """
  Attributes:
   - nodeId
   - inPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nodeId', None, None, ), # 1
    (2, TType.STRING, 'inPath', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, nodeId=None, inPath=None, auth=None,):
    self.nodeId = nodeId
    self.inPath = inPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nodeId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockRead_args')
    if self.nodeId is not None:
      oprot.writeFieldBegin('nodeId', TType.STRING, 1)
      oprot.writeString(self.nodeId)
      oprot.writeFieldEnd()
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 2)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockRead_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockRead_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockWrite_args:
  """
  Attributes:
   - filename
   - hdfsPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'filename', None, None, ), # 1
    (2, TType.STRING, 'hdfsPath', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, filename=None, hdfsPath=None, auth=None,):
    self.filename = filename
    self.hdfsPath = hdfsPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.filename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfsPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockWrite_args')
    if self.filename is not None:
      oprot.writeFieldBegin('filename', TType.STRING, 1)
      oprot.writeString(self.filename)
      oprot.writeFieldEnd()
    if self.hdfsPath is not None:
      oprot.writeFieldBegin('hdfsPath', TType.STRING, 2)
      oprot.writeString(self.hdfsPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockWrite_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockWrite_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class workspaceUpload_args:
  """
  Attributes:
   - filename
   - genome_id
   - desc
   - title
   - srcDate
   - onto_term_id
   - onto_term_def
   - onto_term_name
   - seq_type
   - shock_id
   - src_id
   - working_dir
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'filename', None, None, ), # 1
    (2, TType.STRING, 'genome_id', None, None, ), # 2
    (3, TType.STRING, 'desc', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
    (5, TType.STRING, 'srcDate', None, None, ), # 5
    (6, TType.STRING, 'onto_term_id', None, None, ), # 6
    (7, TType.STRING, 'onto_term_def', None, None, ), # 7
    (8, TType.STRING, 'onto_term_name', None, None, ), # 8
    (9, TType.STRING, 'seq_type', None, None, ), # 9
    (10, TType.STRING, 'shock_id', None, None, ), # 10
    (11, TType.STRING, 'src_id', None, None, ), # 11
    (12, TType.STRING, 'working_dir', None, None, ), # 12
    (13, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 13
  )

  def __init__(self, filename=None, genome_id=None, desc=None, title=None, srcDate=None, onto_term_id=None, onto_term_def=None, onto_term_name=None, seq_type=None, shock_id=None, src_id=None, working_dir=None, auth=None,):
    self.filename = filename
    self.genome_id = genome_id
    self.desc = desc
    self.title = title
    self.srcDate = srcDate
    self.onto_term_id = onto_term_id
    self.onto_term_def = onto_term_def
    self.onto_term_name = onto_term_name
    self.seq_type = seq_type
    self.shock_id = shock_id
    self.src_id = src_id
    self.working_dir = working_dir
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.filename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.genome_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.srcDate = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.onto_term_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.onto_term_def = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.onto_term_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.seq_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.shock_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.src_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.working_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('workspaceUpload_args')
    if self.filename is not None:
      oprot.writeFieldBegin('filename', TType.STRING, 1)
      oprot.writeString(self.filename)
      oprot.writeFieldEnd()
    if self.genome_id is not None:
      oprot.writeFieldBegin('genome_id', TType.STRING, 2)
      oprot.writeString(self.genome_id)
      oprot.writeFieldEnd()
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 3)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.srcDate is not None:
      oprot.writeFieldBegin('srcDate', TType.STRING, 5)
      oprot.writeString(self.srcDate)
      oprot.writeFieldEnd()
    if self.onto_term_id is not None:
      oprot.writeFieldBegin('onto_term_id', TType.STRING, 6)
      oprot.writeString(self.onto_term_id)
      oprot.writeFieldEnd()
    if self.onto_term_def is not None:
      oprot.writeFieldBegin('onto_term_def', TType.STRING, 7)
      oprot.writeString(self.onto_term_def)
      oprot.writeFieldEnd()
    if self.onto_term_name is not None:
      oprot.writeFieldBegin('onto_term_name', TType.STRING, 8)
      oprot.writeString(self.onto_term_name)
      oprot.writeFieldEnd()
    if self.seq_type is not None:
      oprot.writeFieldBegin('seq_type', TType.STRING, 9)
      oprot.writeString(self.seq_type)
      oprot.writeFieldEnd()
    if self.shock_id is not None:
      oprot.writeFieldBegin('shock_id', TType.STRING, 10)
      oprot.writeString(self.shock_id)
      oprot.writeFieldEnd()
    if self.src_id is not None:
      oprot.writeFieldBegin('src_id', TType.STRING, 11)
      oprot.writeString(self.src_id)
      oprot.writeFieldEnd()
    if self.working_dir is not None:
      oprot.writeFieldBegin('working_dir', TType.STRING, 12)
      oprot.writeString(self.working_dir)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 13)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class workspaceUpload_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('workspaceUpload_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockBatchWrite_args:
  """
  Attributes:
   - inPath
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'inPath', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'outPath', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, inPath=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.inPath = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.inPath.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockBatchWrite_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.inPath))
      for iter6 in self.inPath:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 2)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShockBatchWrite_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShockBatchWrite_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snpSamtools_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, inPath=None, organism=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snpSamtools_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snpSamtools_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snpSamtools_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getJobStatus_args:
  """
  Attributes:
   - jobID
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobID', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, jobID=None, auth=None,):
    self.jobID = jobID
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobID = JnomicsThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getJobStatus_args')
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 1)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getJobStatus_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobStatus, JnomicsThriftJobStatus.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getJobStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGridJobStatus_args:
  """
  Attributes:
   - jobID
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobID', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 2
  )

  def __init__(self, jobID=None, auth=None,):
    self.jobID = jobID
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobID = JnomicsThriftJobID()
          self.jobID.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGridJobStatus_args')
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRUCT, 1)
      self.jobID.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGridJobStatus_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGridJobStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllJobs_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllJobs_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllJobs_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(JnomicsThriftJobStatus, JnomicsThriftJobStatus.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = JnomicsThriftJobStatus()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllJobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeVCF_args:
  """
  Attributes:
   - inDir
   - inAlignments
   - outVCF
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inDir', None, None, ), # 1
    (2, TType.STRING, 'inAlignments', None, None, ), # 2
    (3, TType.STRING, 'outVCF', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, inDir=None, inAlignments=None, outVCF=None, auth=None,):
    self.inDir = inDir
    self.inAlignments = inAlignments
    self.outVCF = outVCF
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inAlignments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outVCF = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeVCF_args')
    if self.inDir is not None:
      oprot.writeFieldBegin('inDir', TType.STRING, 1)
      oprot.writeString(self.inDir)
      oprot.writeFieldEnd()
    if self.inAlignments is not None:
      oprot.writeFieldBegin('inAlignments', TType.STRING, 2)
      oprot.writeString(self.inAlignments)
      oprot.writeFieldEnd()
    if self.outVCF is not None:
      oprot.writeFieldBegin('outVCF', TType.STRING, 3)
      oprot.writeString(self.outVCF)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeVCF_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeVCF_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeCovariate_args:
  """
  Attributes:
   - inDir
   - outCov
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inDir', None, None, ), # 1
    (2, TType.STRING, 'outCov', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, inDir=None, outCov=None, auth=None,):
    self.inDir = inDir
    self.outCov = outCov
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outCov = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeCovariate_args')
    if self.inDir is not None:
      oprot.writeFieldBegin('inDir', TType.STRING, 1)
      oprot.writeString(self.inDir)
      oprot.writeFieldEnd()
    if self.outCov is not None:
      oprot.writeFieldBegin('outCov', TType.STRING, 2)
      oprot.writeString(self.outCov)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeCovariate_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeCovariate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkRealign_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, inPath=None, organism=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkRealign_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkRealign_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkRealign_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkCallVariants_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, inPath=None, organism=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkCallVariants_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkCallVariants_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkCallVariants_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkCountCovariates_args:
  """
  Attributes:
   - inPath
   - organism
   - vcfMask
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'vcfMask', None, None, ), # 3
    (4, TType.STRING, 'outPath', None, None, ), # 4
    (5, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 5
  )

  def __init__(self, inPath=None, organism=None, vcfMask=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.vcfMask = vcfMask
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.vcfMask = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkCountCovariates_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.vcfMask is not None:
      oprot.writeFieldBegin('vcfMask', TType.STRING, 3)
      oprot.writeString(self.vcfMask)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 4)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 5)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkCountCovariates_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkCountCovariates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkRecalibrate_args:
  """
  Attributes:
   - inPath
   - organism
   - recalFile
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'recalFile', None, None, ), # 3
    (4, TType.STRING, 'outPath', None, None, ), # 4
    (5, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 5
  )

  def __init__(self, inPath=None, organism=None, recalFile=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.recalFile = recalFile
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.recalFile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkRecalibrate_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.recalFile is not None:
      oprot.writeFieldBegin('recalFile', TType.STRING, 3)
      oprot.writeString(self.recalFile)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 4)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 5)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gatkRecalibrate_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gatkRecalibrate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class runSNPPipeline_args:
  """
  Attributes:
   - inPath
   - organism
   - outPath
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inPath', None, None, ), # 1
    (2, TType.STRING, 'organism', None, None, ), # 2
    (3, TType.STRING, 'outPath', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, inPath=None, organism=None, outPath=None, auth=None,):
    self.inPath = inPath
    self.organism = organism
    self.outPath = outPath
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.organism = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('runSNPPipeline_args')
    if self.inPath is not None:
      oprot.writeFieldBegin('inPath', TType.STRING, 1)
      oprot.writeString(self.inPath)
      oprot.writeFieldEnd()
    if self.organism is not None:
      oprot.writeFieldBegin('organism', TType.STRING, 2)
      oprot.writeString(self.organism)
      oprot.writeFieldEnd()
    if self.outPath is not None:
      oprot.writeFieldBegin('outPath', TType.STRING, 3)
      oprot.writeString(self.outPath)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class runSNPPipeline_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('runSNPPipeline_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pairReads_args:
  """
  Attributes:
   - file1
   - file2
   - outFile
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file1', None, None, ), # 1
    (2, TType.STRING, 'file2', None, None, ), # 2
    (3, TType.STRING, 'outFile', None, None, ), # 3
    (4, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 4
  )

  def __init__(self, file1=None, file2=None, outFile=None, auth=None,):
    self.file1 = file1
    self.file2 = file2
    self.outFile = outFile
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.file2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.outFile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pairReads_args')
    if self.file1 is not None:
      oprot.writeFieldBegin('file1', TType.STRING, 1)
      oprot.writeString(self.file1)
      oprot.writeFieldEnd()
    if self.file2 is not None:
      oprot.writeFieldBegin('file2', TType.STRING, 2)
      oprot.writeString(self.file2)
      oprot.writeFieldEnd()
    if self.outFile is not None:
      oprot.writeFieldBegin('outFile', TType.STRING, 3)
      oprot.writeString(self.outFile)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 4)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pairReads_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pairReads_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class singleReads_args:
  """
  Attributes:
   - file
   - outFile
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file', None, None, ), # 1
    (2, TType.STRING, 'outFile', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (Authentication, Authentication.thrift_spec), None, ), # 3
  )

  def __init__(self, file=None, outFile=None, auth=None,):
    self.file = file
    self.outFile = outFile
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.outFile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = Authentication()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('singleReads_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRING, 1)
      oprot.writeString(self.file)
      oprot.writeFieldEnd()
    if self.outFile is not None:
      oprot.writeFieldBegin('outFile', TType.STRING, 2)
      oprot.writeString(self.outFile)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class singleReads_result:
  """
  Attributes:
   - success
   - je
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (JnomicsThriftJobID, JnomicsThriftJobID.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'je', (JnomicsThriftException, JnomicsThriftException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, je=None,):
    self.success = success
    self.je = je

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = JnomicsThriftJobID()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.je = JnomicsThriftException()
          self.je.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('singleReads_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.je is not None:
      oprot.writeFieldBegin('je', TType.STRUCT, 1)
      self.je.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
